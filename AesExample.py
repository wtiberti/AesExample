# AES example, 128bit key version using ECB mode
#
# Author : Walter Tiberti <wtuniv at gmail.com>
#

import os
# Key length initialization
key_len = 128

# nÂ° of rounds initialization
numof_rounds = 10
if key_len == 192 :
	numof_rounds = 12
elif key_len == 256 :
	numof_rounds = 14

# Storage for the round keys
bigkey = []

# S-BOX definition for ByteSub operation
s_box = [
	[0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76],
	[0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0],
	[0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15],
	[0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75],
	[0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84],
	[0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF],
	[0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8],
	[0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2],
	[0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73],
	[0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB],
	[0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79],
	[0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08],
	[0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A],
	[0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E],
	[0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF],
	[0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]
	]

# S-BOX definition for InvByteSub operation
inv_s_box = [
	[0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB],
	[0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB],
	[0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E],
	[0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25],
	[0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92],
	[0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84],
	[0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06],
	[0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B],
	[0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73],
	[0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E],
	[0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B],
	[0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4],
	[0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F],
	[0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF],
	[0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61],
	[0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]
	]

#  Multiplication matrix for MixColumn
mix_matrix = [
	[2,3,1,1],
	[1,2,3,1],
	[1,1,2,3],
	[3,1,1,2] ]

#  Multiplication matrix for InvMixColumn
inv_mix_matrix  = [
	[0xE,0xB,0xD,0x9],
	[0x9,0xE,0xB,0xD],
	[0xD,0x9,0xE,0xB],
	[0xB,0xD,0x9,0xE] ]

# Lookup table for the constants (R) used inside the key scheduling part
costanti_r = [
	      0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
	0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
	0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
	0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
	0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
	0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
	0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
	0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
	0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
	0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
	0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
	0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
	0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
	0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d ]


def ByteSub( m ) :
	"""ByteSub Operation"""
	result = ""
	for c in m:
		riga = (ord(c) >> 4) & 0xF
		colonna = ord(c) & 0xF
		result += chr( s_box[riga][colonna] );
	return result

def InvByteSub( m ) :
	"""InvByteSub Operation"""
	result = "";
	for c in m:
		riga = (ord(c) >> 4) & 0xF
		colonna = ord(c) & 0xF
		result += chr( inv_s_box[riga][colonna] );
	return result

def ShiftRows( m ) :
	"""ShiftRows Operation"""
	j = 0;
	result = ""
	for i in range(len(m)) :
		result += m[j]
		j = (j+5) % 16
	return result

def InvShiftRows( m ) :
	"""InvShiftRows Operation"""
	j = 0;
	result = ""
	for i in range(len(m)) :
		result += m[j]
		j = (j+13) % 16
	return result

def MixColumn( m ) :
	"""MixColumn Operation"""
	result = ""
	pezzi_da_4 = [m[i:i+4] for i in range(0, len(m), 4)]
	for pezzo in pezzi_da_4 :
		for riga in mix_matrix :
			temp = 0
			for k in range(4) :
				temp ^= GaloisMul(riga[k], ord(pezzo[k]))

			result += chr( temp & 0xFF )
	return result

def InvMixColumn( m ) :
	"""InvMixColumn Operation"""
	result = ""
	pezzi_da_4 = [m[i:i+4] for i in range(0, len(m), 4)]
	for pezzo in pezzi_da_4 :
		for riga in inv_mix_matrix :
			temp = 0
			for k in range(4) :
				temp ^= GaloisMul(riga[k], ord(pezzo[k]))
			result += chr( temp & 0xFF )
	return result

def GaloisMul( b1, b2 ) :
	"""Helper function for galois field multiplication""" 
	p = 0
	for bit_i in range(8) :
		if (b2 & 1) != 0 :
			p ^= b1
		bit_alto = b1 & 0x80
		b1 <<= 1
		if bit_alto != 0 :
			b1 ^= 0x1B
		b2 >>= 1;
	return p
		
def AddRoundKey( m, k ) :
	"""AddRoundKey Operatiob"""
	result = ""
	for i in range(len(k)) :
		s = ord(m[i])
		t = ord(k[i])
		result += chr( (s^t) & 0xFF )
	return result

def InvAddRoundKey( m, k ) :
	"""InvAddRoundKey Operation"""
	result = ""
	k_bis = MixKey( k );
	for i in range(len(k)) :
		s = ord(m[i])
		t = ord(k_bis[i])
		result += chr( (s^t) & 0xFF )
	return result

def MixKey( k ) :
	"""Creates the key used inside InvAddRoundKey"""
	result = ""
	pezzi_da_4 = [k[i:i+4] for i in range(0, len(k), 4)]
	for rigamx in mix_matrix :
		for colonnachiave in pezzi_da_4 :
			temp = 0
			for i in range(4) :
				temp ^= GaloisMul(rigamx[i], ord(colonnachiave[i]))
			result += chr( temp & 0xFF )
	return result
	

def Trasforma( p, i ) :
	"""Transform funtion used in round keys generation"""
	#1 shift
	temp = p[1:] + p[0]
	#2 s_box
	temp = ByteSub(temp)
	#3 costants
	r = costanti_r[(i-4)/4]
	#4 last component
	result = ""
	result += chr( (ord(temp[0]) ^ r) & 0xFF )
	result += temp[1]
	result += temp[2]
	result += temp[3]
	#5 end
	return result

def CalcolaChiave( k ) :
	"""Creates ALL the round keys"""
	nuova_matrice = [k[i:i+4] for i in range(0, len(k), 4)]
	
	for i in range(4,44) :
		temp = ""
		if i%4 != 0 :
			temp += AddRoundKey( nuova_matrice[i-4], nuova_matrice[i-1] )
		else :
			temp += AddRoundKey( nuova_matrice[i-4], Trasforma(nuova_matrice[i-1], i) )
		nuova_matrice.append( temp )
	return nuova_matrice

def RoundKey( roundn, bigkey ) :
	"""Retrieve the correct round key"""
	result = str(bigkey[4*roundn]) + \
		 str(bigkey[4*roundn+1]) + \
		 str(bigkey[4*roundn+2]) + \
		 str(bigkey[4*roundn+3])
	return result

def Encrypt( m, k ) :
	"""Main CRYPTING function"""
	global bigkey

	# Round 0
	roundkey = RoundKey( 0, bigkey )
	print "Round " + str(0) + ", key:",
	PrintHex(roundkey);
	m = AddRoundKey(m, roundkey);

	for round_i in range(1,numof_rounds) :
		print "--- ROUND " + str(round_i) + " ---"
		print "input: ",
		PrintHex(m)
		
		fase1 = ByteSub(m)
		print "BS: ",
		PrintHex(fase1)

		fase2 = ShiftRows(fase1)
		print "SR: ",
		PrintHex(fase2)

		fase3 = MixColumn(fase2)
		print "MX: ",
		PrintHex(fase3)

		roundkey = RoundKey( round_i, bigkey )
		fase4 = AddRoundKey(fase3, roundkey)
		print "Round " + str(round_i) + ", key:",
		PrintHex(roundkey);
		print "ARK: ",
		PrintHex(fase4)
		m = fase4
	# Last round
	finale1 = ByteSub(m);
	finale2 = ShiftRows(finale1);
	roundkey = RoundKey( numof_rounds, bigkey )
	print "Round " + str(numof_rounds) + ", key:",
	PrintHex(roundkey);
	finale3 = AddRoundKey(finale2, roundkey);
	print "\nResult:"
	PrintHex(finale3);
	return finale3;

def Decrypt( m, k ) :
	"""Main DECRYPTING function"""
	global bigkey
	roundkey = RoundKey( 10, bigkey )
	print "Round " + str(10) + ", chiave:",
	PrintHex(roundkey);
	m = AddRoundKey(m, roundkey);

	for round_i in range(numof_rounds-1,0,-1) :
		print "--- ROUND " + str(round_i) + " ---"
		print "input: ",
		PrintHex(m)
		
		fase1 = InvByteSub(m)
		print "InvBS: ",
		PrintHex(fase1)

		fase2 = InvShiftRows(fase1)
		print "InvSR: ",
		PrintHex(fase2)

		roundkey = RoundKey( round_i, bigkey )
		fase4 = AddRoundKey(fase2, roundkey)
		print "Round " + str(round_i) + ", key:",
		PrintHex(roundkey);
		print "ARK: ",
		PrintHex(fase4)

		fase3 = InvMixColumn(fase4)
		print "InvMX: ",
		PrintHex(fase3)

		m = fase3
	# Last round
	finale1 = InvByteSub(m);
	finale2 = InvShiftRows(finale1);
	roundkey = RoundKey( 0, bigkey )
	print "Round " + str(0) + ", key:",
	PrintHex(roundkey);
	finale3 = AddRoundKey(finale2, roundkey);
	print "\nResult:"
	PrintHex(finale3);
	return finale3;

def PrintHex( l ) :
	for i in l :
		print str(hex(ord(i))),
	print

def PrintAllKeys( bigkeys ) :
	"""Prints out all the round keys"""
	for col in range(11) :
		PrintHex( RoundKey(col, bigkeys) )
	return 0

def main() :
	"""Entrypoint"""
	global bigkey

	# Asks the user for text
	messaggio = raw_input("Enter some text: ");

	# Key used. This is a testing value; you can have the user insert its own key by doing:
	#	chiave = raw_input("Inserire chiave")

	chiave = "\x0F\x15\x71\xc9\x47\xd9\xe8\x59\x0c\xb7\xad\xd6\xaf\x7f\x67\x98"

	# Padding mod 16 with "space" char
	delta = len(messaggio) % (key_len/8)
	messaggio += " " * ((key_len/8) - delta)
	del delta

	# Generating all the round keys
	bigkey = CalcolaChiave( chiave )

	# Split the message in 128bit chunks
	pezzi = [messaggio[i:i+(key_len/8)] for i in range(0, len(messaggio), key_len/8)]
	pezzi_cifrati = []

	for pezzo_i in pezzi :
		# Encrypt separately each chunk (ECB)
		pezzi_cifrati.append( Encrypt( pezzo_i, chiave ) )

	print "-" * 80
	msg_originale = []	
	for pezzo_i in pezzi_cifrati :
		# Dencrypt separately each chunk
		msg_originale.append( Decrypt( pezzo_i, chiave ) )

	print "Mesage: ",
	for pezzo in  msg_originale :
		print pezzo,
	print
	return 0


if __name__ == "__main__" :
	main()
